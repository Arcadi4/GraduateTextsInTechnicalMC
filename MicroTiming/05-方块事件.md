# 04-方块事件

## 4.1 什么是方块事件？

## 4.2 活塞的组成

> 完整意义上的活塞有两部分组成，分别是活塞底座和活塞头。

活塞底座完全控制活塞头，并且活塞有两种状态，分别是`收回`和`伸出`。通常情况下，当活塞处于被激活状态时，其会同时更改其活塞底座为伸出状态，并出现活塞头。当活塞处于收回状态时，其活塞头也随之消失。但是，也有部分手段可以创造出只有伸出的活塞底座没有活塞头的**无头活塞**(更确切地说，并不是没有活塞头，而是将它的活塞头指向了某个其他方块)，我们稍后会详细了解这种特殊状态的活塞。在1.16以前，活塞头只会检查自己后方是否存在活塞底座，而不会在意其朝向，这给了制作“多头活塞”的机会。但是，在1.16后，活塞头不仅会检查身后活塞底座的存在性，还会检查其朝向，使得这种“多头活塞”不复存在。考虑到其在1.20.1的不可行性，我们在此处对其不做讨论。

## 4.3 活塞的自检

> 关于其它类型的自检，可以先查看[其它类型的自检](../BlockUpdate/01-更新概念与不同类型的更新.md)

```java
//被玩家放置
    public void onPlaced(World world, BlockPos pos, BlockState state, LivingEntity placer, ItemStack itemStack) {
        if (!world.isClient) {
            this.tryMove(world, pos, state);
        }

    }
//被NC更新
    public void neighborUpdate(BlockState state, World world, BlockPos pos, Block sourceBlock, BlockPos sourcePos, boolean notify) {
        if (!world.isClient) {
            this.tryMove(world, pos, state);
        }

    }
//被其他东西放置
    public void onBlockAdded(BlockState state, World world, BlockPos pos, BlockState oldState, boolean notify) {
        if (!oldState.isOf(state.getBlock())) {
            if (!world.isClient && world.getBlockEntity(pos) == null) {
                this.tryMove(world, pos, state);
            }

        }
    }
```

活塞当且仅当以下两种情况发生时自检：

- 被放置[^1]
- 被更新
- 被玩家放置

[^1]:值得注意的是，这种放置包括被其它活塞放置。

同时，必须强调的是，活塞的自检是可以发生在任意阶段的，活塞会在任意阶段自检，并视情况决定其是否在方块事件阶段添加事件。

#### 自检流程

```java
private boolean shouldExtend(RedstoneView world, BlockPos pos, Direction pistonFace) {
    // 获取所有方向的枚举值（上、下、北、南、东、西）
    Direction[] var4 = Direction.values();
    int var5 = var4.length;

    // 遍历所有方向
    int var6;
    for (var6 = 0; var6 < var5; ++var6) {
        Direction direction = var4[var6];
        // 如果当前方向不是活塞的面朝向，并且该方向的方块发出红石信号
        if (direction != pistonFace && world.isEmittingRedstonePower(pos.offset(direction), direction)) {
            // 如果某个方向的方块发出红石信号，活塞应当伸展
            return true;
        }
    }

    // 检查活塞下方是否有红石信号
    if (world.isEmittingRedstonePower(pos, Direction.DOWN)) {
        return true;  // 如果下方有红石信号，活塞应当伸展
    } else {
        // 如果下方没有红石信号，检查活塞上方的方块
        BlockPos blockPos = pos.up(); // 获取活塞上方的方块位置
        Direction[] var10 = Direction.values();
        var6 = var10.length;

        // 遍历上方的所有方向
        for (int var11 = 0; var11 < var6; ++var11) {
            Direction direction2 = var10[var11];
            // 如果当前方向不是向下，并且该方向的方块发出红石信号
            if (direction2 != Direction.DOWN && world.isEmittingRedstonePower(blockPos.offset(direction2), direction2)) {
                // 如果上方某个方向的方块发出红石信号，活塞应当伸展
                return true;
            }
        }

        // 如果没有任何方向的方块发出红石信号，活塞不应伸展
        return false;
    }
}
```

```java
private void tryMove(World world, BlockPos pos, BlockState state) {
    // 获取活塞的朝向（通过状态中的FACING属性）
    Direction direction = (Direction)state.get(FACING);
    
    // 判断是否有红石信号
    boolean bl = this.shouldExtend(world, pos, direction);
    
    // 如果应该伸展且活塞当前没有伸展（EXTENDED属性为false）
    if (bl && !(Boolean)state.get(EXTENDED)) {
        // 创建一个PistonHandler对象来尝试推动方块
        // 如果成功推动，则发送一个方块事件
        if ((new PistonHandler(world, pos, direction, true)).calculatePush()) {
            world.addSyncedBlockEvent(pos, this, 0, direction.getId());
        }
    }
    // 如果不应该伸展且活塞当前处于伸展状态（EXTENDED属性为true）
    else if (!bl && (Boolean)state.get(EXTENDED)) {
        // 计算活塞伸展后的目标位置（当前活塞位置 + 2个单位的方向偏移）
        BlockPos blockPos = pos.offset(direction, 2);
        
        // 获取目标位置的方块状态
        BlockState blockState = world.getBlockState(blockPos);
        
        // 初始化状态码（默认为1）
        // 状态码的代表状态：
        // i=0：伸出
        // i=1：收回
        // i=2：瞬推收回
        int i = 1;
        
        // 如果目标方块是一个正在移动的活塞，并且其朝向与当前活塞相同
        if (blockState.isOf(Blocks.MOVING_PISTON) && blockState.get(FACING) == direction) {
            // 获取目标位置的方块实体（即活塞的BlockEntity）
            BlockEntity blockEntity = world.getBlockEntity(blockPos);
            
            // 如果方块实体是PistonBlockEntity
            if (blockEntity instanceof PistonBlockEntity) {
                PistonBlockEntity pistonBlockEntity = (PistonBlockEntity)blockEntity;
                
                // 如果目标活塞正在伸展，且伸展进度小于50%或者当前时间与目标活塞保存的时间相同，或者当前世界正在进行方块更新
                if (pistonBlockEntity.isExtending() && 
                    (pistonBlockEntity.getProgress(0.0F) < 0.5F || world.getTime() == pistonBlockEntity.getSavedWorldTime() || ((ServerWorld)world).isInBlockTick())) {
                    // 如果满足条件，将状态码设置为2
                    i = 2;
                }
            }
        }

        // 发送方块事件
        world.addSyncedBlockEvent(pos, this, i, direction.getId());
    }
}
```

## 4.4 [进阶]b36转化顺序

## 4.5 方块事件

## 4.6 更新顺序

## 4.7 b36的到位

## 4.8 方块事件延迟

## 4.9 复制

## 4.10 信息不一致的方块事件

## 4.11 无头活塞
