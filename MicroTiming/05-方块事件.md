# 05-方块事件

## 5.1 什么是方块事件？

## 5.2 活塞的组成

> 完整意义上的活塞有两部分组成，分别是活塞底座和活塞头。

活塞底座完全控制活塞头，并且活塞有两种状态，分别是`收回`和`伸出`。通常情况下，当活塞处于被激活状态时，其会同时更改其活塞底座为伸出状态，并出现活塞头。当活塞处于收回状态时，其活塞头也随之消失。但是，也有部分手段可以创造出只有伸出的活塞底座没有活塞头的**无头活塞**(更确切地说，并不是没有活塞头，而是将它的活塞头指向了某个其他方块)，我们稍后会详细了解这种特殊状态的活塞。在1.16以前，活塞头只会检查自己后方是否存在活塞底座，而不会在意其朝向，这给了制作“多头活塞”的机会。但是，在1.16后，活塞头不仅会检查身后活塞底座的存在性，还会检查其朝向，使得这种“多头活塞”不复存在。考虑到其在1.20.1的不可行性，我们在此处对其不做讨论。

## 5.3 活塞的自检

> 关于其它类型的自检，可以先查看[其它类型的自检](../BlockUpdate/01-更新概念与不同类型的更新.md)

```java
//被玩家放置
    public void onPlaced(World world, BlockPos pos, BlockState state, LivingEntity placer, ItemStack itemStack) {
        if (!world.isClient) {
            this.tryMove(world, pos, state);
        }

    }
//被NC更新
    public void neighborUpdate(BlockState state, World world, BlockPos pos, Block sourceBlock, BlockPos sourcePos, boolean notify) {
        if (!world.isClient) {
            this.tryMove(world, pos, state);
        }

    }
//被其他东西放置
    public void onBlockAdded(BlockState state, World world, BlockPos pos, BlockState oldState, boolean notify) {
        if (!oldState.isOf(state.getBlock())) {
            if (!world.isClient && world.getBlockEntity(pos) == null) {
                this.tryMove(world, pos, state);
            }

        }
    }
```

活塞当且仅当以下两种情况发生时自检：

- 被放置[^1]
- 被更新
- 被玩家放置

[^1]:值得注意的是，这种放置包括被其它活塞放置。

同时，必须强调的是，活塞的自检是可以发生在任意阶段的，活塞会在任意阶段自检，并视情况决定其是否在方块事件阶段添加事件。

### 5.3.1 活塞对红石信号的检查

```java
private boolean shouldExtend(RedstoneView world, BlockPos pos, Direction pistonFace) {
    // 获取所有方向的枚举值（上、下、北、南、东、西）
    Direction[] var4 = Direction.values();
    int var5 = var4.length;

    // 遍历所有方向
    int var6;
    for (var6 = 0; var6 < var5; ++var6) {
        Direction direction = var4[var6];
        // 如果当前方向不是活塞的面朝向，并且该方向的方块发出红石信号
        if (direction != pistonFace && world.isEmittingRedstonePower(pos.offset(direction), direction)) {
            // 如果某个方向的方块发出红石信号，活塞应当伸展
            return true;
        }
    }

    // 检查活塞下方是否有红石信号
    if (world.isEmittingRedstonePower(pos, Direction.DOWN)) {
        return true;  // 如果下方有红石信号，活塞应当伸展
    } else {
        // 如果下方没有红石信号，检查活塞上方的方块
        BlockPos blockPos = pos.up(); // 获取活塞上方的方块位置
        Direction[] var10 = Direction.values();
        var6 = var10.length;

        // 遍历上方的所有方向
        for (int var11 = 0; var11 < var6; ++var11) {
            Direction direction2 = var10[var11];
            // 如果当前方向不是向下，并且该方向的方块发出红石信号
            if (direction2 != Direction.DOWN && world.isEmittingRedstonePower(blockPos.offset(direction2), direction2)) {
                // 如果上方某个方向的方块发出红石信号，活塞应当伸展
                return true;
            }
        }

        // 如果没有任何方向的方块发出红石信号，活塞不应伸展
        return false;
    }
}
```

接下来我们将详细探讨活塞是如何判断其激活源的。其总是按照以下步骤执行：

1. 活塞检查自身毗邻的方块，不包括其朝向方块，是否发出红石信号，如果发出，则激活活塞
2. 如果直接毗邻活塞的方块没有一个正在发出红石信号，则检查其上方方块毗邻的方块，包括活塞自己，是否发出红石信号，如果发出，则激活活塞
3. 若以上条件都不满足，则不激活活塞

以上步骤揭示了为何活塞具有的重要性质之一，半连接性(Quasi-Connectivity)，简称QC，若不清楚可以返回[QC性质说明](../BlockUpdate/01-更新概念与不同类型的更新.md)查看。

### 5.3.2 活塞自检逻辑

```java
private void tryMove(World world, BlockPos pos, BlockState state) {
    // 获取活塞的朝向（通过状态中的FACING属性）
    Direction direction = (Direction)state.get(FACING);
    
    // 判断是否有红石信号
    boolean bl = this.shouldExtend(world, pos, direction);
    
    // 如果应该伸出且活塞当前没有伸出（EXTENDED属性为false）
    if (bl && !(Boolean)state.get(EXTENDED)) {
        // 创建一个PistonHandler对象来尝试推动方块
        // 如果成功推动，则添加一个方块事件
        if ((new PistonHandler(world, pos, direction, true)).calculatePush()) {
            world.addSyncedBlockEvent(pos, this, 0, direction.getId());
        }
    }
    // 如果不应该伸出且活塞当前处于伸出状态（EXTENDED属性为true）
    else if (!bl && (Boolean)state.get(EXTENDED)) {
        // 计算活塞伸出后的目标位置（当前活塞位置 + 2个单位的方向偏移）
        BlockPos blockPos = pos.offset(direction, 2);
        
        // 获取目标位置的方块状态
        BlockState blockState = world.getBlockState(blockPos);
        
        // 初始化状态码（默认为1）
        // 状态码的代表状态：
        // i=0：伸出
        // i=1：收回
        // i=2：瞬推收回
        int i = 1;
        
        // 如果目标方块是一个正在移动的活塞，并且其朝向与当前活塞相同
        if (blockState.isOf(Blocks.MOVING_PISTON) && blockState.get(FACING) == direction) {
            // 获取目标位置的方块实体（b36）
            BlockEntity blockEntity = world.getBlockEntity(blockPos);
            
            // 如果方块实体是b36
            if (blockEntity instanceof PistonBlockEntity) {
                PistonBlockEntity pistonBlockEntity = (PistonBlockEntity)blockEntity;
                
                // 如果目标活塞正在伸出，且伸展进度小于50%(其它条件不用管)
                if (pistonBlockEntity.isExtending() && 
                    (pistonBlockEntity.getProgress(0.0F) < 0.5F || world.getTime() == pistonBlockEntity.getSavedWorldTime() || ((ServerWorld)world).isInBlockTick())) {
                    // 如果满足条件，将状态码设置为2
                    i = 2;
                }
            }
        }

        // 添加方块事件
        world.addSyncedBlockEvent(pos, this, i, direction.getId());
    }
}
```

现在再让我们看回活塞自检，其总是按照如下步骤执行：

1. 如果活塞处于收回状态但实际上应该伸出，则添加活塞头，若成功伸出，则添加方块事件
2. 如果活塞处于伸出状态但没有红石信号支持，则考虑收回活塞
3. 若自己正在伸出且进度小于50%，则瞬推收回，添加方块事件
4. 否则正常收回，添加方块事件

## 5.4 b36转化顺序

### 5.4.1 可推动方块

```java
public static boolean isMovable(BlockState state, World world, BlockPos pos, Direction direction, boolean canBreak, Direction pistonDir) {
    // 判断方块位置是否在有效的世界区域内
    // pos.getY() >= world.getBottomY() 且 pos.getY() <= world.getTopY() - 1 确保方块在世界的有效Y轴范围内
    // world.getWorldBorder().contains(pos) 确保方块位置在世界边界内
    if (pos.getY() >= world.getBottomY() && pos.getY() <= world.getTopY() - 1 && world.getWorldBorder().contains(pos)) {
        
        // 如果方块是空气，活塞可以推动空气
        if (state.isAir()) {
            return true;
        }
        
        // 如果方块是不可推动的特殊方块（如黑曜石、哭泣的黑曜石、重生锚、强化深板岩等）
        else if (!state.isOf(Blocks.OBSIDIAN) && !state.isOf(Blocks.CRYING_OBSIDIAN) && !state.isOf(Blocks.RESPAWN_ANCHOR) && !state.isOf(Blocks.REINFORCED_DEEPSLATE)) {
            
            // 如果是向下推动且方块处于世界的最低Y值，则不能推动
            if (direction == Direction.DOWN && pos.getY() == world.getBottomY()) {
                return false;
            }
            // 如果是向上推动且方块处于世界的最高Y值，则不能推动
            else if (direction == Direction.UP && pos.getY() == world.getTopY() - 1) {
                return false;
            } 
            else {
                // 如果方块不是活塞本身或粘性活塞
                if (!state.isOf(Blocks.PISTON) && !state.isOf(Blocks.STICKY_PISTON)) {
                    // 如果方块的硬度为-1.0F，表示它是无法破坏的（如某些特殊方块）
                    if (state.getHardness(world, pos) == -1.0F) {
                        return false;
                    }

                    // 根据方块的活塞行为来决定是否可以推动
                    switch (state.getPistonBehavior()) {
                        case BLOCK:
                            // 如果活塞行为是BLOCK，表示方块无法被推动
                            return false;
                        case DESTROY:
                            // 如果活塞行为是DESTROY，表示方块可以被破坏，取决于canBreak参数
                            return canBreak;
                        case PUSH_ONLY:
                            // 如果活塞行为是PUSH_ONLY，只有在推动方向与活塞方向一致时才可以推动
                            return direction == pistonDir;
                    }
                } 
                // 如果方块是活塞本身并且是扩展状态，则不能推动
                else if ((Boolean)state.get(EXTENDED)) {
                    return false;
                }

                // 检查方块是否有方块实体，如果有方块实体，不能被推动
                return !state.hasBlockEntity();
            }
        } else {
            // 如果方块是特殊的不可推动的方块（如黑曜石等），直接返回false
            return false;
        }
    } else {
        // 如果方块位置超出有效世界范围或在世界边界之外，返回false
        return false;
    }
}

```

当活塞判断是否可以推动方块时，总是会做以下判断：

1. 如果活塞的推动在世界边界外，其推动方块会被推到世界边界外，或大于游戏高度上限或小于游戏高度下限，则不会推出。
2. 如果活塞尝试推动的方块是空气，则可以推出
3. 若活塞尝试推动黑曜石，哭泣黑曜石，重生锚，或强化深板岩，则拒绝推出
4. 若活塞尝试推动的方块是硬度为-1的方块（如末地传送门，基岩，屏障等），则拒绝推出
5. 若活塞尝试推动的方块拥有Block活塞行为的属性，则拒绝推出
6. 若活塞尝试推动的方块拥有DESTROY活塞行为属性，则视情况破坏该方块
7. 若活塞尝试推动的方块拥有PUSH_ONLY活塞行为的属性，则只有在活塞推动的方向和活塞方向一致时才能被推动
8. 若活塞尝试推动的方块具有方块实体(如箱子，漏斗等)，则拒绝推出

### 5.4.2 移动结构分析

> 温馨提示，这部分是本章节最为复杂的一部分之一，如果比较懒可以直接使用pistOrder模组而并不需要真正学习本部分在说的内容

```java
public boolean calculatePush() {
    // 清空已移动的方块和已破坏的方块列表，以便重新计算
    this.movedBlocks.clear();
    this.brokenBlocks.clear();

    // 获取活塞将要推动的起始点
    BlockState blockState = this.world.getBlockState(this.posTo);

    // 如果起始点不能推动
    if (!PistonBlock.isMovable(blockState, this.world, this.posTo, this.motionDirection, false, this.pistonDirection)) {
        // 如果方块不可推动且当前处于缩回状态，并且方块行为为DESTROY，则将其标记为破坏
        if (this.retracted && blockState.getPistonBehavior() == PistonBehavior.DESTROY) {
            this.brokenBlocks.add(this.posTo); // 添加到破坏列表
            return true; // 活塞仍然可以进行操作（通过破坏方块）
        } else {
            return false; // 活塞无法推动且无法破坏目标方块
        }
    }
    // 如果目标方块可推动，但无法添加直线结构，无法推动
    else if (!this.tryMove(this.posTo, this.motionDirection)) {
        return false;
    } 
    else {
        // 遍历所有被标记为需要移动的方块
        for (int i = 0; i < this.movedBlocks.size(); ++i) {
            BlockPos blockPos = (BlockPos) this.movedBlocks.get(i);
            
            // 如果当前方块是粘性方块，尝试移动它周围的粘连方块
            if (isBlockSticky(this.world.getBlockState(blockPos)) && !this.tryMoveAdjacentBlock(blockPos)) {
                return false; // 如果移动周围粘连方块失败，则整体推动失败
            }
        }

        return true; // 所有方块都成功移动或处理
    }
}

```

当活塞需要推动时，会先执行以上代码，这段代码是用于分析移动结构的。这里需要更多更为详细的表述以辅助各位读者理解：`movedBlocks`和`brokenBlocks`实际是两个`arrayList`。没有了解过`Java`语言的读者可以简单理解为一个可以随意插入，取出的列表。这段代码本质在按照以下顺序执行操作：

1. 清空`movedBlocks`和`brokenBlocks`两个列表。
2. 检查其起始位置是否可以推动
   - 如果不可推动，则检查其对活塞行为的响应
     - 如果可破坏，则将该方块添加至`brokenBlocks`列表，推动成功
     - 如果不可破坏，则推动失败
   - 如果可推动，则尝试添加其直线结构（我们稍后会解析活塞是如何分析直线结构的）
     - 如果无法添加其直线结构，则推动失败
     - 如果成功添加其直线结构，则遍历所有需要推动的方块
       - 如果存在粘性方块（粘液块和蜂蜜块），则尝试添加分支
         - 若添加失败，则推动失败
     - 如果以上均没有失败，则推动成功

Mojang在这里通过两个方法实现了对直线结构的分析和对分支结构的分析。分别称为`tryMove`[^2]和`tryMoveAdjacentBlock`。

[^2]:这里的`tryMove`是需要消歧义的，在`Java`中，两个在同一个类的方法是可以被赋予相同名字，当且仅当两个方法的传入形参不一致时。

### 5.4.3 直线结构分析

```java
private boolean tryMove(BlockPos pos, Direction dir) {
    // 获取指定位置的方块状态
    BlockState blockState = this.world.getBlockState(pos);

    // 如果方块是空气方块，直接返回true，因为不需要处理空气
    if (blockState.isAir()) {
        return true;
    } 
    // 如果方块不可移动，根据当前条件直接返回true
    else if (!PistonBlock.isMovable(blockState, this.world, pos, this.motionDirection, false, dir)) {
        return true;
    } 
    // 如果方块位置是活塞的初始位置，直接返回true
    else if (pos.equals(this.posFrom)) {
        return true;
    } 
    // 如果方块已经在已移动列表中，直接返回true，避免重复计算
    else if (this.movedBlocks.contains(pos)) {
        return true;
    } 
    else {
        int i = 1; // 初始偏移距离为1

        // 检查当前方块是否是黏性方块，并尝试追踪其连接的其他方块
        if (i + this.movedBlocks.size() > 12) {
            // 如果移动的方块总数超过12个，返回false
            return false;
        } else {
            while (isBlockSticky(blockState)) {
                // 获取黏性方块在相反方向上的下一个方块
                BlockPos blockPos = pos.offset(this.motionDirection.getOpposite(), i);
                BlockState blockState2 = blockState; // 当前方块状态
                blockState = this.world.getBlockState(blockPos); // 下一个方块状态

                // 如果下一个方块是空气、不粘连、不可移动或是活塞初始位置，结束循环
                if (blockState.isAir() 
                    || !isAdjacentBlockStuck(blockState2, blockState) 
                    || !PistonBlock.isMovable(blockState, this.world, blockPos, this.motionDirection, false, this.motionDirection.getOpposite()) 
                    || blockPos.equals(this.posFrom)) {
                    break;
                }

                ++i; // 增加偏移距离
                if (i + this.movedBlocks.size() > 12) {
                    // 如果移动的方块总数超过12个，返回false
                    return false;
                }
            }

            int j = 0; // 用于记录成功移动的方块数量

            // 将所有黏性方块及其连接方块添加到移动列表
            for (int k = i - 1; k >= 0; --k) {
                this.movedBlocks.add(pos.offset(this.motionDirection.getOpposite(), k));
                ++j;
            }

            int k = 1; // 偏移量初始化为1

            // 开始处理推动方向上的方块
            while (true) {
                BlockPos blockPos2 = pos.offset(this.motionDirection, k); // 下一个方块的位置
                int l = this.movedBlocks.indexOf(blockPos2); // 检查方块是否已在移动列表中

                if (l > -1) {
                    // 如果方块已经在移动列表中，调整移动列表的顺序
                    this.setMovedBlocks(j, l);

                    // 遍历调整后的列表，检查所有黏性方块并处理其连接方块
                    for (int m = 0; m <= l + j; ++m) {
                        BlockPos blockPos3 = (BlockPos) this.movedBlocks.get(m);
                        if (isBlockSticky(this.world.getBlockState(blockPos3)) && !this.tryMoveAdjacentBlock(blockPos3)) {
                            return false;
                        }
                    }

                    return true; // 所有相关方块处理成功
                }

                // 获取当前偏移位置的方块状态
                blockState = this.world.getBlockState(blockPos2);

                // 如果当前方块是空气，推动成功
                if (blockState.isAir()) {
                    return true;
                }

                // 如果当前方块不可移动或是活塞的初始位置，返回false
                if (!PistonBlock.isMovable(blockState, this.world, blockPos2, this.motionDirection, true, this.motionDirection) 
                    || blockPos2.equals(this.posFrom)) {
                    return false;
                }

                // 如果当前方块是可破坏的，将其添加到破坏列表
                if (blockState.getPistonBehavior() == PistonBehavior.DESTROY) {
                    this.brokenBlocks.add(blockPos2);
                    return true;
                }

                // 如果移动列表已达到12个方块，返回false
                if (this.movedBlocks.size() >= 12) {
                    return false;
                }

                // 将当前方块添加到移动列表
                this.movedBlocks.add(blockPos2);
                ++j; // 增加移动计数
                ++k; // 增加偏移量
            }
        }
    }
}
```

## 5.5 方块事件

## 5.6 更新顺序

## 5.7 b36的到位

## 5.8 方块事件延迟

## 5.9 复制

## 5.10 信息不一致的方块事件

## 5.11 无头活塞
