<style>
HeightLightNormal { color : Chartreuse }
HeightLightWarning { color : Crimson }
HeightLightAdvanced { color : DarkSeaGreen }
</style>
# #02 刻内时序
![各个阶段](./img/TickPhase.jpg)

## 2.1 刻内时序的观测

> 这天小B做了一个装置：
>
> ![装置](./img/MicroTick02_Intro1.png)

请各位猜猜按下按钮会发生什么？

1. 什么都不会发生
2. 左边活塞伸出了
3. 右边活塞伸出了
4. 两个活塞同时推出
5. 游戏崩溃

> 于是小B按下了按钮
>
> ![装置激活](./img/MicroTick02_Intro2.png)
> 
> 左……左边的活塞伸出了！！！！！！
>
>根据前两天看[01-刻与刻间时序](./01-刻与刻间时序.md)学到的知识：他进行了以下计算：
>
> 这个中继器延迟2gt，那个比较器延迟2gt……？哇两个活塞应该同时推出！那为什么只推出了一个活塞呢？明明是同一gt却有个先后顺序，gt不是最小单位了？
>
> 面对这样的疑问，聪慧至极的小B给出了惊人的结论：~~游戏出bug了！~~

当然不是这样的！所有的玩家都应该建立一个这样的一个观念：在 Minecraft 中，大多数游戏逻辑是运行在单线程中的，这意味着从逻辑层面上看，事件的执行必定是有顺序的，而非严格意义上的同时！

于是一切都解释的通了，在同1gt内必定存在某种更加精细的时序，我们称在1刻内的精细时序为**刻内时序**。正如前文所提到的，进行如上的~~明明理论上是同一gt发生但偏偏有个先后顺序~~的测试，便完成了一次**刻内时序的观测**。

这里还有个例子：
当按下按钮，两个装置分别出现了以下症状：

![装置2激活](./img/MicroTick02_Intro4.gif)

明明在同一gt内，加个中继器就大有不同，怎么有这么诡异的事情！为什么呢？本篇就将简要的探讨以上现象！

什么你问这玩意有什么用？

多的是呢！上到极为复杂的红石装置，下至最最基本的精确时序分析，都用得上。刻内时序理论的研究也在很大程度上促进了红石研究！包括但不限于推动上限检测，BED等听起来**高大上**的红石装置和理论。

这里选取一段Void先生写的文字：

> ...
> 因此，刻内时序的学习之所以必要，不仅仅是为了解决设计中遇到的问题、解释以前无法解释的经验结论。更重要的是，有很多人轻视刻内时序的学习，不愿意学习刻内时序而将其仅仅视为一个问题的来源，在红石设计中常常遇到刻内时序导致的问题，却殊不知刻内时序是红石设计中最强大的工具之一，善用刻内时序的知识可以大大精简红石电路的设计，并提高红石机器的性能。刻内时序知识的缺乏使得许多人从一开始就不知道这件工具是可以利用的，这个情景从社区的良性发展的角度，是需要尽力避免的。

### 2.2 微时序理论
<style>
WTUColor { color: Red }
TTColor { color: #ff7300 }
CTColor { color: #ffae00 }
BEColor { color: Green }
EUColor { color: Blue }
TEColor { color: BlueViolet }
ATColor { color: Purple }
</style>

最小单位为1gt的时序我们称为宏观时序，而当具体分析1gt内的细微行为时，就涉及**微时序**了。

在前文中我们知道，MC执行任何东西总是有优先顺序的，我们通过源码、实验等途径发现——Minecraft在1gt内总是大致按照以下顺序执行固定的事件：

1. <WTUColor>World Tick Update</WTUColor>，简称<WTUColor>WTU</WTUColor>，中文译作世界时间更新。游戏内存在一个和世界绑定的计时器，在世界创建时被初始化为0。在本游戏阶段内，该计时器自增1。我们称第n刻，为包含使得世界计时器增加到n的那个世界事件更新计划的刻。
2. <TTColor>Schedule Tick / Tile Tick / Next Tick Entry*</TTColor>，简称<TTColor>TT</TTColor>/<TTColor>NTE*</TTColor>，中文译作计划刻。（在此处提及NTE和Next Tick Entry的**错误**译名旨在帮助各位读者看懂部分早期的其他文档，不希望各位继续使用这两个名字。）
3. <CTColor>Chunk Tick</CTColor>，简称<CTColor>CT</CTColor>，中文译作区块刻。在此阶段内，当在存在玩家在一定距离内时，会发生作物生长、草方块蔓延、水结冰等事件。在每个区块刻阶段，游戏遍历玩家附近的所有区块，然后在这些区块里面随机选取方块，执行这些事件。
4. <BEColor>Block Event</BEColor>，简称<BEColor>BE</BEColor>，中文译作方块事件。最重要的在方块事件阶段运作的元件是活塞。当活塞发现自己的实际状态和供能状态不符的时候，会添加一个方块事件。在某个方块事件之外添加的方块事件，会等到下一个方块事件阶段执行；在方块事件阶段内添加的方块事件，会在本个方块事件阶段执行。
5. <EUColor>Entity Update</EUColor>，简称<EUColor>EU</EUColor>，中文译作实体运算。实体需要每刻都主动进行运动、实体 AI 等行为。所有的实体行为，比如生物运动、TNT 爆炸、怪物攻击，都发生在这个阶段。非玩家踩下压力板、绊线使得它们产生红石信号，也发生在这个阶段。
6. <TEColor>Block Entity / Tile Entity</TEColor>，简称<TEColor>TE</TEColor>，中文译作方块实体。有部分方块需要每刻运行自己相关的逻辑，这些事情发生在方块实体阶段。漏斗会在方块实体阶段吸取物品、传输物品；被活塞推动的方块，会变成移动中的方块（b36），它们会在自己创建后的前两次方块实体阶段进行推动实体的逻辑，并且在第三次方块实体阶段变回普通的方块。
7. <ATColor>Async Task / Network Update</ATColor>，简称<ATColor>AT</ATColor>/<ATColor>NU</ATColor>，中文译作异步事件。也可称为Player Action/玩家操作。玩家操作实际上是从客户端发往服务端的网络数据包。在每一刻的结尾，服务端会统一执行所有在这一刻内收到的
玩家操作数据包。

这些是在平常分析时主要涉及的游戏阶段，后文中我们也会围绕这些事件展开叙述。

### 2.3 瞬时元件

我们称一个元件的某种行为是瞬时的，当且仅当该行为一旦被触发就立即计算，中间无法插入任何操作。瞬时的行为可以在任意阶段执行，它发生的阶段是触发它的事件发生的阶段。

> 比如说，红石粉亮灭是瞬时的，如果玩家关闭了一个拉杆，那么可以导致红石粉在玩家操作阶段熄灭，但是如果活塞推走了一个红石块，就可以导致红石粉在方块事件阶段熄灭。

### 2.4 常见元件的运行阶段

| 元件种类 | 运行阶段 |
| :---: | :---: |
| 命令方块运行指令 | <TTColor>计划刻TT</TTColor> |
| 中继器、比较器、红石火把、侦测器的亮灭 | <TTColor>计划刻TT</TTColor> |
| 红石粉、铁轨改变状态 | 瞬时 |
| 栅栏门、活板门改变状态 | 瞬时 |
| 漏斗因红石信号改变状态 | 瞬时 |
| 漏斗吸收、传递物品 | <TEColor>方块实体TE</TEColor> |
| 音符盒、钟因红石信号改变状态 | 瞬时 |
| 音符盒、钟发出声音 | <BEColor>方块事件BE</BEColor> |
| 发射器、投掷器因红石信号改变状态 | 瞬时 |
| 发射器发射/投掷器投出物品 | <TTColor>计划刻TT</TTColor> |
| 红石灯的亮起 | 瞬时 |
| 红石灯的熄灭 | <TTColor>计划刻TT</TTColor> |
| 按钮、压力板、绊线的亮起 | 瞬时[^1] |
| 按钮、压力板、绊线的熄灭 | <TTColor>计划刻TT</TTColor> |
| 重力方块判定下落、创建实体 | <TTColor>计划刻TT</TTColor> |
| 重力方块下落、到位 | <EUColor>实体运算EU</EUColor> |
| 活塞推出或收回 | <BEColor>方块事件BE</BEColor> |
| b36[^2] 推动实体 | <TEColor>方块实体TE</TEColor> |
| b36 自然到位 | <TEColor>方块实体TE</TEColor> |
| b36 被粘性活塞收回到位[^3] | <BEColor>方块事件BE</BEColor> |

[^1]: 但是压力板的亮起只能由实体运动触发，所以实际上只能在实体运算或玩家操作；类似地，按钮只能被玩家或者箭矢按下，所以也限制在这两个阶段。

[^2]: b36 : minecraft:moving_piston,移动中的活塞。

[^3]: 当粘性活塞收回的时候前方是 b36，则会立刻将其到位，也就是所说的粘性活塞短脉冲。

### 2.5 刻内时序基础分析

<!-- #### 侦测器的计划刻行为

在侦测器执行一个计划刻的时候，会根据自己的亮灭状态执行如下行为：

|侦测器的亮灭| 侦测器的行为 |
|---|---|
|已亮起| 熄灭 |
|未亮起| 侦测器亮起，然后给自己添加一个延迟2gt的计划刻 |

#### 侦测器对面前方块发出pp更新的响应行为

当侦测器面前的方块发出PP更新时，如果侦测器处在熄灭状态，且当前位置并不已经有侦测器的计划刻*，则给自己计划一个延迟为 2 刻,（优先级为 0）的计划刻。

> 由于计划刻的执行逻辑，在当前gt即将执行的计划刻不会视为“存在计划刻”。也就是说，如果在某一gt侦测器将会亮起，而在侦测器亮起前对侦测器发出PP更新，此时侦测器也会添加计划刻。具体行为和实例详见进阶部分。 -->

<!-- ### 2.2.5 计划刻段的段内时序计算

### 2.2.6 计划刻列表的类抑制现象

### 2.2.7 [进阶]计划刻的世界层与区块层

## 2.3方块实体

### 2.3.1方块实体的概念

### 2.3.2容器，比较器2

### 2.3.3方块实体阶段的段内时序

## 2.4方块事件

### 2.4.1 活塞，粘性活塞

### 2.4.2 b36的到位方式与行为

### 2.4.3[进阶] b36转化内部时序

### 2.4.4[进阶] TNT复制的详细原理

### 2.4.5 活塞收回的特殊行为

### 2.4.5 方块事件队列

### 2.4.6 方块事件延迟

### 2.4.7 无头活塞 -->
